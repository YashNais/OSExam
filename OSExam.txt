#1
#!/bin/bash

# Function to check if a number is prime
is_prime() {
    local num=$1

    if (( num < 2 )); then
        echo "$num is not a prime number."
        return
    fi


    if (( num == 2 )); then
        echo "$num is a prime number."
        return
    fi

    if (( num % 2 == 0 )); then
        echo "$num is not a prime number."
        return
    fi

    for (( i=3; i*i<=num; i+=2 )); do
        if (( num % i == 0 )); then
            echo "$num is not a prime number."
            return
        fi
    done

    echo "$num is a prime number."
}

read -p "Enter a number: " number
is_prime "$number"

########################
#Armstrong

#!/bin/bash
read -p "Enter a number: " num
original_num=$num
sum=0
num_digits=${#num}
while (( num > 0 )); do
    digit=$(( num % 10 ))
    sum=$(( sum + digit ** num_digits ))
    num=$(( num / 10 ))
done
if (( sum == original_num )); then
    echo "$original_num is an Armstrong number."
else
    echo "$original_num is not an Armstrong number."
fi

#############################
#Factorial
#!/bin/bash

# Prompt the user to enter a number
read -p "Enter a number: " num
factorial=1

# Calculate the factorial
for (( i=1; i<=num; i++ )); do
    factorial=$(( factorial * i ))
done

# Output the result
echo "The factorial of $num is $factorial."

#######################
#Palindrome

#!/bin/bash

# Prompt the user to enter a number
read -p "Enter a number: " num
original_num=$num
reverse=0

# Calculate the reverse of the number
while (( num > 0 )); do
    digit=$(( num % 10 ))
    reverse=$(( reverse * 10 + digit ))
    num=$(( num / 10 ))
done

# Check if the original number is equal to its reverse
if (( original_num == reverse )); then
    echo "$original_num is a palindrome."
else
    echo "$original_num is not a palindrome."
fi

#######################################3
#Bubble sort
#!/bin/bash

# Prompt the user to enter numbers
read -p "Enter numbers separated by spaces: " -a arr
n=${#arr[@]}

# Perform Bubble Sort
for (( i = 0; i < n-1; i++ )); do
    for (( j = 0; j < n-i-1; j++ )); do
        if (( arr[j] > arr[j+1] )); then
            # Swap arr[j] and arr[j+1]
            temp=${arr[j]}
            arr[j]=${arr[j+1]}
            arr[j+1]=$temp
        fi
    done
done

# Output the sorted array
echo "Sorted array: ${arr[@]}"

######################
#Substrings
#!/bin/bash

# Prompt the user to enter the main string
read -p "Enter the main string: " str

# Prompt the user to enter the substring to search for
read -p "Enter the substring to count: " substr

# Count occurrences of the substring in the main string
count=$(grep -o "$substr" <<< "$str" | wc -l)

# Output the result
echo "The substring '$substr' occurs $count times in the main string."


'

///////////////////////////////////////

/2
/*Design menu driven application demonstrating use of different system calls.
1) Process related system call: fork, exit, wait
2) File realted system call: open, read, write, close, link, unlink, stat
3) Communication system call: pipe, fifo
4) Information related system call: sleep, alarm */


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <string.h>

void process_calls();
void file_calls();
void communication_calls();
void info_calls();

int main() {
    int choice;

    while (1) {
        printf("\nMenu Driven Application for System Calls\n");
        printf("1. Process Related System Calls\n");
        printf("2. File Related System Calls\n");
        printf("3. Communication Related System Calls\n");
        printf("4. Information Related System Calls\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                process_calls();
                break;
            case 2:
                file_calls();
                break;
            case 3:
                communication_calls();
                break;
            case 4:
                info_calls();
                break;
            case 5:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Please try again.\n");
        }
    }

    return 0;
}

void process_calls() {
    int pid = fork();

    if (pid < 0) {
        printf("Fork failed.\n");
    } else if (pid == 0) {
        printf("Child process. PID: %d\n", getpid());
        exit(0);
    } else {
        wait(NULL);
        printf("Parent process. PID: %d\n", getpid());
    }
}

void file_calls() {
    char filename[100], buffer[100];
    int fd, bytes;
    struct stat fileStat;

    printf("Enter filename: ");
    scanf("%s", filename);

    fd = open(filename, O_CREAT | O_RDWR, 0666);
    if (fd < 0) {
        printf("Error opening file.\n");
        return;
    }

    printf("Writing to the file...\n");
    write(fd, "This is a test file.\n", 21);

    lseek(fd, 0, SEEK_SET);
    bytes = read(fd, buffer, sizeof(buffer));
    if (bytes < 0) {
        printf("Error reading file.\n");
        close(fd);
        return;
    }

    buffer[bytes] = '\0';
    printf("Content of %s:\n%s\n", filename, buffer);

    close(fd);

    printf("Creating a hard link to the file.\n");
    if (link(filename, "hardlink_file") == 0) {
        printf("Hard link created: hardlink_file\n");
    } else {
        printf("Error creating hard link.\n");
    }

    if (stat(filename, &fileStat) == 0) {
        printf("File size: %ld bytes\n", fileStat.st_size);
        printf("File inode: %ld\n", fileStat.st_ino);
        printf("File permissions: %o\n", fileStat.st_mode);
    } else {
        printf("Error getting file status.\n");
    }

    printf("Removing the hard link.\n");
    if (unlink("hardlink_file") == 0) {
        printf("Hard link removed: hardlink_file\n");
    } else {
        printf("Error removing hard link.\n");
    }
}

void communication_calls() {
    int fd[2];
    pid_t pid;
    char write_msg[] = "Hello, this is a message through pipe";
    char read_msg[100];
    char fifo_name[] = "my_fifo";

    if (pipe(fd) == -1) {
        printf("Pipe failed.\n");
        return;
    }

    pid = fork();

    if (pid < 0) {
        printf("Fork failed.\n");
        return;
    }

    if (pid > 0) {
        close(fd[0]);  
        write(fd[1], write_msg, strlen(write_msg) + 1);
        close(fd[1]); 
        wait(NULL);
    } else {
        close(fd[1]); 
        read(fd[0], read_msg, sizeof(read_msg));
        printf("Received message: %s\n", read_msg);
        close(fd[0]);
        exit(0);
    }

    if (mkfifo(fifo_name, 0666) == -1) {
        printf("Error creating FIFO.\n");
        return;
    }

    pid = fork();

    if (pid < 0) {
        printf("Fork failed.\n");
        return;
    }

    if (pid > 0) {
        fd[1] = open(fifo_name, O_WRONLY);
        write(fd[1], write_msg, strlen(write_msg) + 1);
        close(fd[1]);
        wait(NULL); 
    } else {
        fd[0] = open(fifo_name, O_RDONLY);
        read(fd[0], read_msg, sizeof(read_msg));
        printf("Received message from FIFO: %s\n", read_msg);
        close(fd[0]);
        exit(0);
    }

    unlink(fifo_name); 
}

void info_calls() {
    unsigned int seconds;

    printf("Enter time in seconds for sleep: ");
    scanf("%u", &seconds);

    printf("Sleeping for %u seconds...\n", seconds);
    sleep(seconds);
    printf("Woke up after %u seconds.\n", seconds);

    printf("Setting an alarm for 5 seconds.\n");
    alarm(5);
    pause();  
}

/////////////////////////////////////
/3


/*Implement multithreading for Matrix Operations using Pthreads.*/

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define MAX 100

int matA[MAX][MAX], matB[MAX][MAX], result[MAX][MAX];
int rowA, colA, rowB, colB;

void* multiply(void* arg);
void* add(void* arg);
void* subtract(void* arg);
void* transposeA(void* arg);
void* transposeB(void* arg);


void* multiply(void* arg) {
    intptr_t row = (intptr_t)arg;  
    for (int i = 0; i < colB; i++) 
    {
        result[row][i] = 0;
        for (int j = 0; j < colA; j++) {
            result[row][i] += matA[row][j] * matB[j][i];
        }
    }
    pthread_exit(0);
}

void* add(void* arg) {
    intptr_t row = (intptr_t)arg; 
    for (int i = 0; i < colA; i++) {
        result[row][i] = matA[row][i] + matB[row][i];
    }
    pthread_exit(0);
}

void* subtract(void* arg) {
    intptr_t row = (intptr_t)arg;  
    for (int i = 0; i < colA; i++) {
        result[row][i] = matA[row][i] - matB[row][i];
    }
    pthread_exit(0);
}


void* transposeA(void* arg) {
    intptr_t row = (intptr_t)arg;  
    for (int i = 0; i < colA; i++) {
        result[i][row] = matA[row][i];
    }
    pthread_exit(0);
}

void* transposeB(void* arg) {
    intptr_t row = (intptr_t)arg;  
    for (int i = 0; i < colB; i++) {
        result[i][row] = matB[row][i];
    }
    pthread_exit(0);
}

void create_threads(void* (*operation)(void*), int rows) {
    pthread_t threads[MAX];

    for (int i = 0; i < rows; i++) {
        pthread_create(&threads[i], NULL, operation, (void*)(intptr_t)i);
    }

    for (int i = 0; i < rows; i++) {
        pthread_join(threads[i], NULL);
    }
}

int main() {
    int choice;

    printf("Enter the number of rows and columns for matrix A: ");
    scanf("%d %d", &rowA, &colA);

    printf("Enter the elements of matrix A:\n");
    for (int i = 0; i < rowA; i++) {
        for (int j = 0; j < colA; j++) {
            scanf("%d", &matA[i][j]);
        }
    }

    printf("Enter the number of rows and columns for matrix B: ");
    scanf("%d %d", &rowB, &colB);

    if (colA != colB || rowA != rowB) {
        printf("For addition, subtraction, and transpose, matrices must have the same dimensions.\n");
        return -1;
    }

    printf("Enter the elements of matrix B:\n");
    for (int i = 0; i < rowB; i++) {
        for (int j = 0; j < colB; j++) {
            scanf("%d", &matB[i][j]);
        }
    }

    while (1) {

        printf("\nChoose the matrix operation:\n");
        printf("1. Matrix Multiplication\n");
        printf("2. Matrix Addition\n");
        printf("3. Matrix Subtraction\n");
        printf("4. Transpose of Matrix A\n");
        printf("5. Transpose of Matrix B\n");
        printf("0. Exit\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                if (colA != rowB) {
                    printf("Matrix multiplication not possible, invalid dimensions.\n");
                    break;
                }
                create_threads(multiply, rowA);
                break;

            case 2:
                create_threads(add, rowA);
                break;

            case 3:
                create_threads(subtract, rowA);
                break;

            case 4:
                create_threads(transposeA, rowA);
                break;

            case 5:
                create_threads(transposeB, rowB);
                break;

            case 0:
                printf("Exiting...\n");
                return 0;  

            default:
                printf("Invalid choice.\n");
        }

        printf("Resultant matrix:\n");
        for (int i = 0; i < rowA; i++) {
            for (int j = 0; j < colB; j++) {
                printf("%d ", result[i][j]);
            }
            printf("\n");
        }
    }

    return 0;
}

/////////////////////////////////////
/4


//Implementation of Classical problems (reader writer)  using Threads and Mutex

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define NUM_READERS 5
#define NUM_WRITERS 2

pthread_mutex_t mutex;           
pthread_mutex_t readCountMutex; 
int readCount = 0;             
int sharedData = 0;            

void* reader(void* arg) {
    int id = *((int*)arg);
    while (1) {
        
        pthread_mutex_lock(&readCountMutex);
        readCount++;
        if (readCount == 1) {
            pthread_mutex_lock(&mutex);  
        }
        pthread_mutex_unlock(&readCountMutex);

        
        printf("Reader %d: reading shared data = %d\n", id, sharedData);
        sleep(1);  

        
        pthread_mutex_lock(&readCountMutex);
        readCount--;
        if (readCount == 0) {
            pthread_mutex_unlock(&mutex);  
        }
        pthread_mutex_unlock(&readCountMutex);

        sleep(1);  
    }
    return NULL;
}

void* writer(void* arg) {
    int id = *((int*)arg);
    while (1) {
        
        pthread_mutex_lock(&mutex); 

        
        sharedData++;  
        printf("Writer %d: writing shared data = %d\n", id, sharedData);
        sleep(2);  

        pthread_mutex_unlock(&mutex);  
        sleep(2);  
    }
    return NULL;
}

int main() {
    pthread_t readers[NUM_READERS];
    pthread_t writers[NUM_WRITERS];
    int ids[NUM_READERS + NUM_WRITERS];

  
    pthread_mutex_init(&mutex, NULL);
    pthread_mutex_init(&readCountMutex, NULL);

    
    for (int i = 0; i < NUM_READERS; i++) {
        ids[i] = i + 1; 
        pthread_create(&readers[i], NULL, reader, &ids[i]);
    }

    
    for (int i = 0; i < NUM_WRITERS; i++) {
        ids[NUM_READERS + i] = i + 1;  
        pthread_create(&writers[i], NULL, writer, &ids[NUM_READERS + i]);
    }

    
    for (int i = 0; i < NUM_READERS; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < NUM_WRITERS; i++) {
        pthread_join(writers[i], NULL);
    }

   
    pthread_mutex_destroy(&mutex);
    pthread_mutex_destroy(&readCountMutex);
    return 0;
}

///////////////////////////////////
/5


//Implementation of Classical problems( producer consumer)  using Threads and Mutex

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE 5
int buffer[BUFFER_SIZE];
int count = 0;

pthread_mutex_t mutex;

void* producer(void* arg) {
    while (1) {
        pthread_mutex_lock(&mutex);  
        if (count < BUFFER_SIZE) {
            buffer[count] = rand() % 100;  
            printf("Produced: %d, count: %d\n", buffer[count], count + 1); 
            count++; 
        }
        pthread_mutex_unlock(&mutex);  
        sleep(1);  
    }
}

void* consumer(void* arg) {
    while (1) {
        pthread_mutex_lock(&mutex);  
        if (count > 0) {
            printf("Consumed: %d, count: %d\n", buffer[count - 1], count - 1); 
            count--;  
        }
        pthread_mutex_unlock(&mutex);  
        sleep(1);  
    }
}


int main() {
    pthread_t prod_thread, cons_thread;

    pthread_mutex_init(&mutex, NULL);

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    pthread_mutex_destroy(&mutex);

    return 0;
}

///////////////////////
/6

//Implementation of Classical problems (reader writer) using Threads and Semaphore. 

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define NUM_READERS 5
#define NUM_WRITERS 2

sem_t rw_mutex;    
sem_t readCountSem;  
int readCount = 0;
int sharedData = 0;

void* reader(void* arg) {
    int id = *((int*)arg);
    while (1) {
        sem_wait(&readCountSem);
        readCount++;
        if (readCount == 1) {
            sem_wait(&rw_mutex);
        }
        sem_post(&readCountSem);

        printf("Reader %d: reading shared data = %d\n", id, sharedData);
        sleep(1);

        sem_wait(&readCountSem);
        readCount--;
        if (readCount == 0) {
            sem_post(&rw_mutex);
        }
        sem_post(&readCountSem);

        sleep(1);
    }
    return NULL;
}

void* writer(void* arg) {
    int id = *((int*)arg);
    while (1) {
        sem_wait(&rw_mutex);
        sharedData++;
        printf("Writer %d: writing shared data = %d\n", id, sharedData);
        sleep(2);
        sem_post(&rw_mutex);
        sleep(2);
    }
    return NULL;
}

int main() {
    pthread_t readers[NUM_READERS];
    pthread_t writers[NUM_WRITERS];
    int ids[NUM_READERS + NUM_WRITERS];

    sem_init(&rw_mutex, 0, 1);
    sem_init(&readCountSem, 0, 1);

    for (int i = 0; i < NUM_READERS; i++) {
        ids[i] = i + 1;
        pthread_create(&readers[i], NULL, reader, &ids[i]);
    }

    for (int i = 0; i < NUM_WRITERS; i++) {
        ids[NUM_READERS + i] = i + 1;
        pthread_create(&writers[i], NULL, writer, &ids[NUM_READERS + i]);
    }

    for (int i = 0; i < NUM_READERS; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < NUM_WRITERS; i++) {
        pthread_join(writers[i], NULL);
    }

    sem_destroy(&rw_mutex);
    sem_destroy(&readCountSem);
    return 0;
}

///////////////////////////////////////////
/7


//Implementation of Classical problems (producer consumer,) using Threads and Semaphore. 

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE 5
int buffer[BUFFER_SIZE];
int count = 0;

sem_t empty;   
sem_t full;    
sem_t mutex;   

void* producer(void* arg) {
    while (1) {
        int item = rand() % 100;  
        sem_wait(&empty);  
        sem_wait(&mutex);  

        buffer[count] = item;
        printf("Produced: %d, count: %d\n", item, count + 1);
        count++;  

        sem_post(&mutex);  
        sem_post(&full);   
        sleep(1);  
    }
}

void* consumer(void* arg) {
    while (1) {
        sem_wait(&full);  
        sem_wait(&mutex);  

        count--;
        printf("Consumed: %d, count: %d\n", buffer[count], count);

        sem_post(&mutex);  
        sem_post(&empty);  
        sleep(1);  
    }
}

int main() {
    pthread_t prod_thread, cons_thread;

    sem_init(&empty, 0, BUFFER_SIZE); 
    sem_init(&full, 0, 0); 
    sem_init(&mutex, 0, 1);  

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);

    return 0;
}

///////////////////////////////////////////////////

/8


//Implementation of Classical problems (dining philosopher) using Threads and Semaphore

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5

sem_t forks[NUM_PHILOSOPHERS];   
sem_t room; 

void* philosopher(void* arg) {
    int philosopher_id = *(int*)arg;

    while (1) {
      
        printf("Philosopher %d is thinking.\n", philosopher_id);
        sleep(rand() % 3);  

       
        sem_wait(&room);  //must always be atleast 1 thinker


        printf("Philosopher %d is hungry and tries to pick up forks.\n", philosopher_id);
        
        sem_wait(&forks[philosopher_id]);  
        sem_wait(&forks[(philosopher_id + 1) % NUM_PHILOSOPHERS]); 

        printf("Philosopher %d is eating.\n", philosopher_id);
        sleep(rand() % 2);  

        sem_post(&forks[philosopher_id]); 
        sem_post(&forks[(philosopher_id + 1) % NUM_PHILOSOPHERS]); 

        printf("Philosopher %d finished eating and puts down forks.\n", philosopher_id);

        sem_post(&room);
    }
}

int main() {
    pthread_t philosophers[NUM_PHILOSOPHERS];
    int ids[NUM_PHILOSOPHERS];

    sem_init(&room, 0, NUM_PHILOSOPHERS - 1); 

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_init(&forks[i], 0, 1);
        ids[i] = i;
    }


    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_create(&philosophers[i], NULL, philosopher, &ids[i]);
    }


    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(philosophers[i], NULL);
    }


    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_destroy(&forks[i]);
    }
    sem_destroy(&room);

    return 0;
}

///////////////////////////////////////////////////////////

/9


//Write a program to compute the finish time, turnaround time and waiting time for the First come First serve

#include <stdio.h>

int main() {
    int n, i;
    
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    
    int arrival_time[n], burst_time[n], finish_time[n], turnaround_time[n], waiting_time[n];
    
    for (i = 0; i < n; i++) {
        printf("Enter Arrival Time and Burst Time for Process %d: ", i + 1);
        scanf("%d %d", &arrival_time[i], &burst_time[i]);
    }

    int current_time = 0;
    for (i = 0; i < n; i++) {

        if (current_time < arrival_time[i]) {
            current_time = arrival_time[i];
        }
        
        finish_time[i] = current_time + burst_time[i];
        
        current_time = finish_time[i];
        
        turnaround_time[i] = finish_time[i] - arrival_time[i];
        waiting_time[i] = turnaround_time[i] - burst_time[i];
    }

    printf("\nProcess\tArrival Time\tBurst Time\tFinish Time\tTurnaround Time\tWaiting Time\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, arrival_time[i], burst_time[i], finish_time[i], turnaround_time[i], waiting_time[i]);
    }

    return 0;
}

////////////////////////////////////
/10


//Write a program to compute the finish time, turnaround time and waiting time for the Shortest Job First (Preemptive and Non Preemptive) 


#include <stdio.h>
#include <limits.h>

struct Process {
    int pid;         
    int bt;        
    int art;         
    int finishTime;  
};

void findWaitingTimePreemptive(struct Process proc[], int n, int wt[]) {
    int rt[n];  
    for (int i = 0; i < n; i++)
        rt[i] = proc[i].bt;

    int complete = 0, t = 0, minm = INT_MAX;
    int shortest = -1, finish_time;
    int check = 0;

    while (complete != n) {
        minm = INT_MAX;
        check = 0;

        for (int j = 0; j < n; j++) {
            if ((proc[j].art <= t) && (rt[j] < minm) && rt[j] > 0) {
                minm = rt[j];
                shortest = j;
                check = 1;
            }
        }

        if (check == 0) {
            t++;
            continue;
        }

    
        rt[shortest]--;

    
        if (rt[shortest] == 0) {
            complete++;
            finish_time = t + 1;
            proc[shortest].finishTime = finish_time; 
            wt[shortest] = finish_time - proc[shortest].bt - proc[shortest].art;

            if (wt[shortest] < 0)
                wt[shortest] = 0;
        }

    
        t++;
    }
}


void findWaitingTimeNonPreemptive(struct Process proc[], int n, int wt[]) {
    int complete = 0, t = 0;
    int minm = INT_MAX, shortest = -1;
    int finish_time;

 
    int done[n];
    for (int i = 0; i < n; i++) {
        done[i] = 0;  
    }

    while (complete != n) {
        minm = INT_MAX;
        shortest = -1;

        for (int j = 0; j < n; j++) {
            if ((proc[j].art <= t) && !done[j] && proc[j].bt < minm) {
                minm = proc[j].bt;
                shortest = j;
            }
        }

        if (shortest == -1) {
            t++;
            continue;
        }

    
        done[shortest] = 1;

  
        t += proc[shortest].bt;
        proc[shortest].finishTime = t;
        wt[shortest] = proc[shortest].finishTime - proc[shortest].bt - proc[shortest].art;

        if (wt[shortest] < 0)
            wt[shortest] = 0;

        complete++;
    }
}

void findTurnAroundTime(struct Process proc[], int n, int wt[], int tat[]) {
    for (int i = 0; i < n; i++)
        tat[i] = proc[i].bt + wt[i];
}


void displayResults(struct Process proc[], int n, int wt[], int tat[]) {
    printf("\nProcess\tArrival\tBurst\tFinish\tWaiting\tTurnaround\n");
    for (int i = 0; i < n; i++) {
        printf("  %d\t  %d\t  %d\t  %d\t  %d\t  %d\n",
               proc[i].pid, proc[i].art, proc[i].bt,
               proc[i].finishTime, wt[i], tat[i]);
    }
}

void findTimes(struct Process proc[], int n, int choice) {
    int wt[n], tat[n];

    if (choice == 1) {
     
        findWaitingTimePreemptive(proc, n, wt);
    } else {
     
        findWaitingTimeNonPreemptive(proc, n, wt);
    }

    findTurnAroundTime(proc, n, wt, tat);
    displayResults(proc, n, wt, tat);
}


int main() {
    int n, choice;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process proc[n];
    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter arrival time and burst time for Process %d: ", proc[i].pid);
        scanf("%d %d", &proc[i].art, &proc[i].bt);
    }


    printf("\nChoose the Scheduling type:\n");
    printf("1. Preemptive SJF\n");
    printf("2. Non-Preemptive SJF\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    findTimes(proc, n, choice);

    return 0;
}

///////////////////////////////

/11


//Write a program to compute the finish time, turnaround time and waiting time for the Priority (Preemptive and Non Preemptive)


#include <stdio.h>
#include <limits.h>

struct Process {
    int pid;        
    int bt;       
    int art;      
    int prt;        
    int finishTime;  
};


void findWaitingTimePreemptive(struct Process proc[], int n, int wt[]) {
    int rt[n]; 
    for (int i = 0; i < n; i++)
        rt[i] = proc[i].bt;

    int complete = 0, t = 0, minm = INT_MAX;
    int highestPriority = -1, finish_time;
    int check = 0;

   
    while (complete != n) {
        minm = INT_MAX;
        check = 0;

       
        for (int j = 0; j < n; j++) {
            if ((proc[j].art <= t) && (rt[j] > 0) && (proc[j].prt < minm)) {
                minm = proc[j].prt;
                highestPriority = j;
                check = 1;
            }
        }

        if (check == 0) {
            t++;
            continue;
        }

    
        rt[highestPriority]--;

     
        if (rt[highestPriority] == 0) {
            complete++;
            finish_time = t + 1;
            proc[highestPriority].finishTime = finish_time; 
            wt[highestPriority] = finish_time - proc[highestPriority].bt - proc[highestPriority].art;

            if (wt[highestPriority] < 0)
                wt[highestPriority] = 0;
        }

  
        t++;
    }
}


void findWaitingTimeNonPreemptive(struct Process proc[], int n, int wt[]) {
    int complete = 0, t = 0;
    int minm = INT_MAX, highestPriority = -1;
    int finish_time;

    
    int done[n];
    for (int i = 0; i < n; i++) {
        done[i] = 0;  
    }

    while (complete != n) {
        minm = INT_MAX;
        highestPriority = -1;

    
        for (int j = 0; j < n; j++) {
            if ((proc[j].art <= t) && !done[j] && proc[j].prt < minm) {
                minm = proc[j].prt;
                highestPriority = j;
            }
        }

        if (highestPriority == -1) {
           
            t++;
            continue;
        }

       
        done[highestPriority] = 1;

     
        t += proc[highestPriority].bt;
        proc[highestPriority].finishTime = t;
        wt[highestPriority] = proc[highestPriority].finishTime - proc[highestPriority].bt - proc[highestPriority].art;

        if (wt[highestPriority] < 0)
            wt[highestPriority] = 0;

        complete++;
    }
}


void findTurnAroundTime(struct Process proc[], int n, int wt[], int tat[]) {
    for (int i = 0; i < n; i++)
        tat[i] = proc[i].bt + wt[i];
}


void displayResults(struct Process proc[], int n, int wt[], int tat[]) {
    printf("\nProcess\tArrival\tBurst\tPriority\tFinish\tWaiting\tTurnaround\n");
    for (int i = 0; i < n; i++) {
        printf("  %d\t  %d\t  %d\t  %d\t  %d\t  %d\t  %d\n",
               proc[i].pid, proc[i].art, proc[i].bt, proc[i].prt,
               proc[i].finishTime, wt[i], tat[i]);
    }
}


void findTimes(struct Process proc[], int n, int choice) {
    int wt[n], tat[n];

    if (choice == 1) {
       
        findWaitingTimePreemptive(proc, n, wt);
    } else {
     
        findWaitingTimeNonPreemptive(proc, n, wt);
    }

    findTurnAroundTime(proc, n, wt, tat);
    displayResults(proc, n, wt, tat);
}


int main() {
    int n, choice;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process proc[n];
    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter arrival time, burst time, and priority for Process %d: ", proc[i].pid);
        scanf("%d %d %d", &proc[i].art, &proc[i].bt, &proc[i].prt);
    }

    
    printf("\nChoose the Scheduling type:\n");
    printf("1. Preemptive Priority\n");
    printf("2. Non-Preemptive Priority\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    findTimes(proc, n, choice);

    return 0;
}

//////////////////////////////

/12
//Round Robin
#include <stdio.h>

void main() {
    int i, j, NOP, sum = 0, count = 0, quantum;
    int at[10], bt[10], temp[10], finish_time[10], turnaround_time[10], waiting_time[10];
    int wt = 0, tat = 0;


    printf("Enter total number of processes: ");
    scanf("%d", &NOP);


    for (i = 0; i < NOP; i++) {
        printf("\nEnter the Arrival and Burst time of Process[%d]:\n", i + 1);
        printf("Arrival time: ");
        scanf("%d", &at[i]);
        printf("Burst time: ");
        scanf("%d", &bt[i]);
        temp[i] = bt[i];  
    }

    
    printf("Enter the Time Quantum for the processes: ");
    scanf("%d", &quantum);

    
    printf("\nProcess No\tArrival Time\tBurst Time\tFinish Time\tTurnaround Time\tWaiting Time\n");

    int y = NOP;
    for (sum = 0, i = 0; y > 0;) {
        if (temp[i] <= quantum && temp[i] > 0) {
            sum += temp[i];
            finish_time[i] = sum;
            temp[i] = 0;
            count = 1;
        } else if (temp[i] > 0) {
            temp[i] -= quantum;
            sum += quantum;
        }
        
      
        if (temp[i] == 0 && count == 1) {
            y--; 
            turnaround_time[i] = finish_time[i] - at[i];
            waiting_time[i] = turnaround_time[i] - bt[i];

            
            printf("P[%d]\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, at[i], bt[i], finish_time[i], turnaround_time[i], waiting_time[i]);

            wt += waiting_time[i];
            tat += turnaround_time[i];
            count = 0;
        }

        
        if (i == NOP - 1) {
            i = 0;
        } else if (at[i + 1] <= sum) {
            i++;
        } else {
            i = 0;
        }
    }

}

////////////////////////////////////

/13

//Write a program to check whether given system is in safe state or not using Bankerâ€™s  Deadlock Avoidance algorithm.

#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

void calculate_need(int need[MAX_PROCESSES][MAX_RESOURCES], int max[MAX_PROCESSES][MAX_RESOURCES], int allocation[MAX_PROCESSES][MAX_RESOURCES], int num_processes, int num_resources) {
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
        }
    }
}

bool is_safe_state(int processes[], int available[], int max[MAX_PROCESSES][MAX_RESOURCES], int allocation[MAX_PROCESSES][MAX_RESOURCES], int num_processes, int num_resources) {
    int need[MAX_PROCESSES][MAX_RESOURCES];
    calculate_need(need, max, allocation, num_processes, num_resources);
    
    bool finish[MAX_PROCESSES] = {false}; 
    int safe_sequence[MAX_PROCESSES];
    int work[MAX_RESOURCES];

    for (int i = 0; i < num_resources; i++) {
        work[i] = available[i];
    }

    int count = 0;
    while (count < num_processes) {
        bool found = false;
        for (int p = 0; p < num_processes; p++) {
            if (finish[p] == false) { 
                int j;
                for (j = 0; j < num_resources; j++) {
                    if (need[p][j] > work[j])
                        break;
                }
                if (j == num_resources) { 
                    
                    for (int k = 0; k < num_resources; k++) {
                        work[k] += allocation[p][k]; 
                    }
                    safe_sequence[count++] = p;
                    finish[p] = true;
                    found = true;
                    break;  
                }
            }
        }
        if (found == false) {
            printf("System is not in a safe state.\n");
            return false;
        }
    }

 
    printf("System is in a safe state.\nSafe sequence is: ");
    for (int i = 0; i < num_processes; i++) {
        printf("%d ", safe_sequence[i]);
    }
    printf("\n");

    return true;
}

int main() {
    int num_processes, num_resources;

    printf("Enter the number of processes: ");
    scanf("%d", &num_processes);

    printf("Enter the number of resources: ");
    scanf("%d", &num_resources);

    int processes[MAX_PROCESSES];
    int available[MAX_RESOURCES];
    int max[MAX_PROCESSES][MAX_RESOURCES];
    int allocation[MAX_PROCESSES][MAX_RESOURCES];

    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }

    printf("Enter the maximum matrix:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &max[i][j]);
        }
    }

    printf("Enter the available resources:\n");
    for (int i = 0; i < num_resources; i++) {
        scanf("%d", &available[i]);
    }

    is_safe_state(processes, available, max, allocation, num_processes, num_resources);

    return 0;
}

/////////////////////////////

/14


//Write a program for Deadlock detection algorithm

#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

void calculate_need(int need[MAX_PROCESSES][MAX_RESOURCES], int request[MAX_PROCESSES][MAX_RESOURCES], int allocation[MAX_PROCESSES][MAX_RESOURCES], int num_processes, int num_resources) {
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            need[i][j] = request[i][j] - allocation[i][j];
        }
    }
}

bool is_safe_state(int processes[], int available[], int request[MAX_PROCESSES][MAX_RESOURCES], int allocation[MAX_PROCESSES][MAX_RESOURCES], int num_processes, int num_resources) {
    int need[MAX_PROCESSES][MAX_RESOURCES];
    calculate_need(need, request, allocation, num_processes, num_resources);
    
    bool finish[MAX_PROCESSES] = {false};
    int work[MAX_RESOURCES];

    for (int i = 0; i < num_resources; i++) {
        work[i] = available[i];
    }

    for (int count = 0; count < num_processes; count++) {
        int p = processes[count];

        if (!finish[p]) {
            int j;
            for (j = 0; j < num_resources; j++) {
                if (need[p][j] > work[j])
                    break;
            }
            if (j == num_resources) {
                for (int k = 0; k < num_resources; k++) {
                    work[k] += allocation[p][k];
                }
                finish[p] = true;
            } else {
                printf("System is in deadlock for the given process order.\n");
                return false;
            }
        }
    }

    printf("System is not in deadlock for the given process order.\n");
    return true;
}

int main() {
    int num_processes, num_resources;

    printf("Enter the number of processes: ");
    scanf("%d", &num_processes);

    printf("Enter the number of resources: ");
    scanf("%d", &num_resources);

    int processes[MAX_PROCESSES];
    int available[MAX_RESOURCES];
    int request[MAX_PROCESSES][MAX_RESOURCES];
    int allocation[MAX_PROCESSES][MAX_RESOURCES];

    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }

    printf("Enter the request matrix:\n");
    for (int i = 0; i < num_processes; i++) {
        for (int j = 0; j < num_resources; j++) {
            scanf("%d", &request[i][j]);
        }
    }

    printf("Enter the available resources:\n");
    for (int i = 0; i < num_resources; i++) {
        scanf("%d", &available[i]);
    }

    printf("Enter the process order (e.g., for P0, P1, P2 enter 0 1 2):\n");
    for (int i = 0; i < num_processes; i++) {
        scanf("%d", &processes[i]);
    }

    is_safe_state(processes, available, request, allocation, num_processes, num_resources);

    return 0;
}

//////////////////////////
/15


//Write a program to calculate the number of page faults for a reference string for the FIFO page replacement algorithms

#include <stdio.h>

int main() {
    int num_pages, num_frames;
    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &num_pages);

    int reference_string[num_pages];
    printf("Enter the reference string:\n");
    for (int i = 0; i < num_pages; i++) {
        scanf("%d", &reference_string[i]);
    }

    printf("Enter the number of frames: ");
    scanf("%d", &num_frames);

    int frames[num_frames]; 
    int page_faults = 0;
    int next_to_replace = 0; 

    
    for (int i = 0; i < num_frames; i++) {
        frames[i] = -1;
    }

    
    for (int i = 0; i < num_pages; i++) {
        int page = reference_string[i];
        int found = 0;

        
        for (int j = 0; j < num_frames; j++) {
            if (frames[j] == page) {
                found = 1;
                break;
            }
        }

        
        if (!found) {
            frames[next_to_replace] = page;
            next_to_replace = (next_to_replace + 1) % num_frames; 
            page_faults++;
        }
    }

    printf("Total number of page faults: %d\n", page_faults);

    return 0;
}


//////////////////////////////////////

/16


//Write a program to calculate the number of page faults for a reference string for the LRU page replacement algorithms: 

#include <stdio.h>
#include <stdbool.h>

#define MAX_FRAMES 10
#define MAX_PAGES 100


int LRU(int reference_string[], int n, int frames) {
    int page_faults = 0;
    int frames_array[MAX_FRAMES];
    int last_used[MAX_FRAMES];
    int time = 0; 

    
    for (int i = 0; i < frames; i++) {
        frames_array[i] = -1;
        last_used[i] = -1;
    }

    
    for (int i = 0; i < n; i++) {
        int page = reference_string[i];
        bool found = false;

        
        for (int j = 0; j < frames; j++) {
            if (frames_array[j] == page) {
                found = true;
                last_used[j] = time++; 
                break;
            }
        }

        
        if (!found) {
            page_faults++;
            int lru_index = 0;
            int min_time = last_used[0];

         
            for (int j = 1; j < frames; j++) {
                if (last_used[j] < min_time) {
                    min_time = last_used[j];
                    lru_index = j;
                }
            }

 
            frames_array[lru_index] = page;
            last_used[lru_index] = time++;  
        }
    }

    return page_faults;
}

int main() {
    int reference_string[MAX_PAGES];
    int n, frames;


    printf("Enter the number of pages: ");
    scanf("%d", &n);

    printf("Enter the reference string: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &reference_string[i]);
    }

   
    printf("Enter the number of frames: ");
    scanf("%d", &frames);

  
    int page_faults = LRU(reference_string, n, frames);


    printf("Total page faults: %d\n", page_faults);

    return 0;
}

///////////////////////////////////

/17


//Write a program to calculate the number of page faults for a reference string for the Optimal page replacement algorithms: 

#include <stdio.h>
#include <stdlib.h>

#define MAX_FRAMES 10
#define MAX_PAGES 100


int findOptimal(int reference_string[], int frames_array[], int current_page, int n, int frames) {
    int farthest = -1;
    int replace_index = -1;


    for (int i = 0; i < frames; i++) {
        int j;

        for (j = current_page; j < n; j++) {
            if (frames_array[i] == reference_string[j]) {
                break;
            }
        }


        if (j == n) {
            return i;
        }


        if (j > farthest) {
            farthest = j;
            replace_index = i;
        }
    }

    return replace_index;
}

int optimalPageReplacement(int reference_string[], int n, int frames) {
    int page_faults = 0;
    int frames_array[MAX_FRAMES];

    for (int i = 0; i < frames; i++) {
        frames_array[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        int page = reference_string[i];
        int found = 0;

        for (int j = 0; j < frames; j++) {
            if (frames_array[j] == page) {
                found = 1;
                break;
            }
        }


        if (!found) {
            page_faults++;
            int replace_index = -1;

            for (int j = 0; j < frames; j++) {
                if (frames_array[j] == -1) {
                    replace_index = j;
                    break;
                }
            }


            if (replace_index == -1) {
                replace_index = findOptimal(reference_string, frames_array, i + 1, n, frames);
            }

            frames_array[replace_index] = page;
        }
    }

    return page_faults;
}

int main() {
    int reference_string[MAX_PAGES];
    int n, frames;

    printf("Enter the number of pages: ");
    scanf("%d", &n);

    printf("Enter the reference string: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &reference_string[i]);
    }

    printf("Enter the number of frames: ");
    scanf("%d", &frames);


    int page_faults = optimalPageReplacement(reference_string, n, frames);

    printf("Total page faults: %d\n", page_faults);

    return 0;
}

//////////////////////////////////////////

/18


//Write a program to simulate FCFS disk scheduling. Calculate total seek time.Print accepted input and output in tabular format

#include <stdio.h>
#include <stdlib.h>

void fcfsDiskScheduling(int requests[], int num_requests, int initial_position) {
    int total_seek_time = 0;
    int current_position = initial_position;
    
    printf("Request No.\tRequested Track\tSeek Time\tCumulative Seek Time\n");

    for (int i = 0; i < num_requests; i++) {
        int seek_time = abs(requests[i] - current_position);
        total_seek_time += seek_time;

        printf("%d\t\t%d\t\t%d\t\t%d\n", i + 1, requests[i], seek_time, total_seek_time);
        
        current_position = requests[i];
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main() {
    int num_requests, initial_position;

    printf("Enter the number of disk requests: ");
    scanf("%d", &num_requests);

    int requests[num_requests];

    printf("Enter the disk requests:\n");
    for (int i = 0; i < num_requests; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial position of the disk arm: ");
    scanf("%d", &initial_position);

    fcfsDiskScheduling(requests, num_requests, initial_position);

    return 0;
}

////////////////////////
/19


//Write a program to simulate SSTF disk scheduling. Calculate total seek time.Print accepted input and output in tabular format

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

int calculate_SSTF(int requests[], int num_requests, int initial_head) {
    int seek_time = 0;
    int visited[MAX_REQUESTS] = {0}; 
    int current_head = initial_head;

    for (int i = 0; i < num_requests; i++) {
        int min_seek_time = 10000; 
        int next_request_index = -1;

        for (int j = 0; j < num_requests; j++) {
            if (!visited[j]) { 
                int seek = abs(current_head - requests[j]);
                if (seek < min_seek_time) {
                    min_seek_time = seek;
                    next_request_index = j;
                }
            }
        }

        visited[next_request_index] = 1;
        seek_time += min_seek_time;
        current_head = requests[next_request_index];
    }

    return seek_time;
}

int main() {
    int num_requests, initial_head;
    
    printf("Enter the number of disk requests: ");
    scanf("%d", &num_requests);

    int requests[MAX_REQUESTS];

    printf("Enter the disk requests (separated by spaces): ");
    for (int i = 0; i < num_requests; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial position of the disk head: ");
    scanf("%d", &initial_head);

    int total_seek_time = 0;
    int visited[MAX_REQUESTS] = {0};
    int current_head = initial_head;

    printf("\nRequest No.\tRequested Track\tSeek Time\tCumulative Seek Time\n");

    for (int i = 0; i < num_requests; i++) {
        int min_seek_time = 10000;
        int next_request_index = -1;

        for (int j = 0; j < num_requests; j++) {
            if (!visited[j]) {
                int seek = abs(current_head - requests[j]);
                if (seek < min_seek_time) {
                    min_seek_time = seek;
                    next_request_index = j;
                }
            }
        }

        visited[next_request_index] = 1;
        total_seek_time += min_seek_time;

        printf("%d\t\t%d\t\t%d\t\t%d\n", i + 1, requests[next_request_index], min_seek_time, total_seek_time);
        current_head = requests[next_request_index];
    }

    return 0;
}


////////////////////////////
/20


//Write a program to simulate SCAN disk scheduling. Calculate total seek time.Print accepted input and output in tabular format

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

void sort(int requests[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (requests[i] > requests[j]) {
                int temp = requests[i];
                requests[i] = requests[j];
                requests[j] = temp;
            }
        }
    }
}

void scan_disk_scheduling(int requests[], int n, int head, int disk_size) {
    int total_seek_time = 0, seek_time;
    int left[MAX_REQUESTS], right[MAX_REQUESTS];
    int left_count = 0, right_count = 0;


    for (int i = 0; i < n; i++) {
        if (requests[i] < head)
            left[left_count++] = requests[i];
        else
            right[right_count++] = requests[i];
    }


    sort(left, left_count);
    sort(right, right_count);


    char direction;
    if (left_count == 0) 
    {
        direction = 'R';
    } 
    else if (right_count == 0) 
    {
        direction = 'L';  
    } 
    else 
    {
     
        if (abs(head - left[left_count - 1]) < abs(head - right[0])) {
            direction = 'L';  
        } else {
            direction = 'R'; 
        }
    }

    printf("Direction: %c\n", direction);

    printf("\nRequest No.\tRequested Track\tSeek Time\tCumulative Seek Time\n");
    int cumulative_seek_time = 0;


    if (direction == 'L' || direction == 'l') {

        if (left_count > 0) {

            seek_time = head;
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t0\t\t%d\t\t%d\n", 1, seek_time, cumulative_seek_time);

            for (int i = left_count - 1; i >= 0; i--) {
                seek_time = abs(left[i] - head);
                total_seek_time += seek_time;
                cumulative_seek_time += seek_time;
                printf("%d\t\t%d\t\t%d\t\t%d\n", left_count - i + 1, left[i], seek_time, cumulative_seek_time);
                head = left[i];
            }
        }

        if (right_count > 0) {

            for (int i = 0; i < right_count; i++) {
                seek_time = abs(right[i] - head);
                total_seek_time += seek_time;
                cumulative_seek_time += seek_time;
                printf("%d\t\t%d\t\t%d\t\t%d\n", left_count + i + 2, right[i], seek_time, cumulative_seek_time);
                head = right[i];
            }
        }
    } else if (direction == 'R' || direction == 'r') {

        if (right_count > 0) {

            for (int i = 0; i < right_count; i++) {
                seek_time = abs(right[i] - head);
                total_seek_time += seek_time;
                cumulative_seek_time += seek_time;
                printf("%d\t\t%d\t\t%d\t\t%d\n", i + 1, right[i], seek_time, cumulative_seek_time);
                head = right[i];
            }
        }

        if (left_count > 0) {

            for (int i = left_count - 1; i >= 0; i--) {
                seek_time = abs(left[i] - head);
                total_seek_time += seek_time;
                cumulative_seek_time += seek_time;
                printf("%d\t\t%d\t\t%d\t\t%d\n", right_count + left_count - i + 1, left[i], seek_time, cumulative_seek_time);
                head = left[i];
            }
        }
    }

    printf("\nTotal seek time: %d\n", total_seek_time);
}

int main() {
    int requests[MAX_REQUESTS], n, head, disk_size;

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the disk requests (separated by spaces): ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial position of the disk head: ");
    scanf("%d", &head);

    printf("Enter the total disk size (maximum track number): ");
    scanf("%d", &disk_size);

    scan_disk_scheduling(requests, n, head, disk_size);

    return 0;
}


//////////////////////////

//21


//Write a program to simulate C-SCAN disk scheduling. Calculate total seek time.Print accepted input and output in tabular format

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100


void sort(int requests[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (requests[i] > requests[j]) {
                int temp = requests[i];
                requests[i] = requests[j];
                requests[j] = temp;
            }
        }
    }
}

void cscan_disk_scheduling(int requests[], int n, int head, int disk_size) {
    int total_seek_time = 0, seek_time;
    int left[MAX_REQUESTS], right[MAX_REQUESTS];
    int left_count = 0, right_count = 0;

    for (int i = 0; i < n; i++) {
        if (requests[i] < head)
            left[left_count++] = requests[i];
        else
            right[right_count++] = requests[i];
    }


    sort(left, left_count);
    sort(right, right_count);

    char direction;
    if (right_count > 0 && (left_count == 0 || (right[0] - head) < (head - left[left_count - 1]))) {
        direction = 'R'; 
    } else {
        direction = 'L';  
    }

    printf("\nAutomatically determined direction: %c\n", direction);
    printf("\nRequest No.\tRequested Track\tSeek Time\tCumulative Seek Time\n");

    int cumulative_seek_time = 0;
    int request_no = 1;

    if (direction == 'R') {

        for (int i = 0; i < right_count; i++) {
            seek_time = abs(right[i] - head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, right[i], seek_time, cumulative_seek_time);
            head = right[i];
        }

        if (head < disk_size) {
            seek_time = abs(disk_size - head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, disk_size, seek_time, cumulative_seek_time);
            head = disk_size;
        }

        seek_time = abs(disk_size - 0);
        total_seek_time += seek_time;
        cumulative_seek_time += seek_time;
        printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, 0, seek_time, cumulative_seek_time);
        head = 0;

        for (int i = 0; i < left_count; i++) {
            seek_time = abs(left[i] - head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, left[i], seek_time, cumulative_seek_time);
            head = left[i];
        }
    } else {  

        for (int i = left_count - 1; i >= 0; i--) {
            seek_time = abs(left[i] - head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, left[i], seek_time, cumulative_seek_time);
            head = left[i];
        }

        if (head > 0) {
            seek_time = abs(head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, 0, seek_time, cumulative_seek_time);
            head = 0;
        }

        seek_time = abs(disk_size - 0);
        total_seek_time += seek_time;
        cumulative_seek_time += seek_time;
        printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, disk_size, seek_time, cumulative_seek_time);
        head = disk_size;

        for (int i = 0; i < right_count; i++) {
            seek_time = abs(right[i] - head);
            total_seek_time += seek_time;
            cumulative_seek_time += seek_time;
            printf("%d\t\t%d\t\t%d\t\t%d\n", request_no++, right[i], seek_time, cumulative_seek_time);
            head = right[i];
        }
    }

    printf("\nTotal seek time: %d\n", total_seek_time);
}

int main() {
    int requests[MAX_REQUESTS], n, head, disk_size;

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the disk requests (separated by spaces): ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial position of the disk head: ");
    scanf("%d", &head);

    printf("Enter the total disk size (maximum track number): ");
    scanf("%d", &disk_size);

    cscan_disk_scheduling(requests, n, head, disk_size);

    return 0;
}


//////////////////////////////////

//22


//Write a program  for following 1)  zombie process 2),orphan processes 3)sum of even numbers of an array in parent and odd numbers of an array in child process

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid > 0) { 
        printf("Parent process PID: %d\n", getpid());
        printf("Parent is sleeping for 5 seconds...\n");
        sleep(5);  
        printf("Parent process exits.\n");
    } else if (pid == 0) {  
        printf("Child process PID: %d\n", getpid());
        printf("Child process is done.\n");
        exit(0);  
    } else {
        perror("Fork failed");
        return 1;
    }

    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid > 0) {  
        printf("Parent process PID: %d\n", getpid());
        printf("Parent process is terminating, making the child an orphan.\n");
        exit(0); 
    } 
    else if (pid == 0) {  
        sleep(5);  
        printf("Orphan child process PID: %d, New Parent PID: %d\n", getpid(), getppid());
    } 
    else {
        perror("Fork failed");
        return 1;
    }

    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    int even_sum = 0, odd_sum = 0;
    pid_t pid = fork();

    if (pid > 0) {  
        for (int i = 0; i < n; i++) {
            if (arr[i] % 2 == 0) {
                even_sum += arr[i];
            }
        }
        printf("Parent process PID: %d\n", getpid());
        printf("Sum of even numbers: %d\n", even_sum);
        wait(NULL); 
    } else if (pid == 0) { 
        for (int i = 0; i < n; i++) {
            if (arr[i] % 2 != 0) {
                odd_sum += arr[i];
            }
        }
        printf("Child process PID: %d\n", getpid());
        printf("Sum of odd numbers: %d\n", odd_sum);
        exit(0);
    } else {
        perror("Fork failed");
        return 1;
    }

    return 0;
}

//////////////////////////

//23

#!/bin/bash

DB_FILE="students.txt"

insert_record() {
    echo "Enter Student ID:"
    read id
    echo "Enter Name:"
    read name
    echo "Enter Age:"
    read age
    echo "Enter Course:"
    read course

    echo "$id,$name,$age,$course" >> "$DB_FILE"
    echo "Record inserted successfully."
}


delete_record() {
    echo "Enter Student ID to delete:"
    read id
    if grep -q "^$id," "$DB_FILE"; then
        grep -v "^$id," "$DB_FILE" > temp.txt && mv temp.txt "$DB_FILE"
        echo "Record deleted successfully."
    else
        echo "Record with ID $id not found."
    fi
}

update_record() {
    echo "Enter Student ID to update:"
    read id
    if grep -q "^$id," "$DB_FILE"; then
        echo "Enter new Name:"
        read name
        echo "Enter new Age:"
        read age
        echo "Enter new Course:"
        read course

        grep -v "^$id," "$DB_FILE" > temp.txt
        echo "$id,$name,$age,$course" >> temp.txt
        mv temp.txt "$DB_FILE"
        echo "Record updated successfully."
    else
        echo "Record with ID $id not found."
    fi
}


search_record() {
    echo "Enter Student ID to search:"
    read id
    if grep -q "^$id," "$DB_FILE"; then
        echo "Record found:"
        grep "^$id," "$DB_FILE"
    else
        echo "Record with ID $id not found."
    fi
}

while true; do
    echo "Choose an operation:"
    echo "a) Insert"
    echo "b) Delete"
    echo "c) Update"
    echo "d) Search"
    echo "e) Exit"
    read -p "Enter your choice: " choice

    case $choice in
        a) insert_record ;;
        b) delete_record ;;
        c) update_record ;;
        d) search_record ;;
        e) echo "Exiting..."; break ;;
        *) echo "Invalid choice. Please try again." ;;
    esac
done


////////////////////////
//24


//Write a program to read and copy the contents of file character by character, line by line.

#include <stdio.h>
#include <stdlib.h>

void copy_char_by_char(FILE *source, FILE *destination) {
    char ch;
    while ((ch = fgetc(source)) != EOF) {
        fputc(ch, destination);
    }
    printf("File copied character by character successfully.\n");
}

void copy_line_by_line(FILE *source, FILE *destination) {
    char buffer[1024]; 
    while (fgets(buffer, sizeof(buffer), source) != NULL) {
        fputs(buffer, destination);
    }
    printf("File copied line by line successfully.\n");
}

int main() {
    char source_file[100], dest_file[100];
    int choice;

    printf("Enter the source file name: ");
    scanf("%s", source_file);
    printf("Enter the destination file name: ");
    scanf("%s", dest_file);

    FILE *source = fopen(source_file, "r");
    if (source == NULL) {
        perror("Error opening source file");
        return EXIT_FAILURE;
    }

    FILE *destination = fopen(dest_file, "w");
    if (destination == NULL) {
        perror("Error opening destination file");
        fclose(source);
        return EXIT_FAILURE;
    }


    printf("Choose copy method:\n1. Copy character by character\n2. Copy line by line\n");
    scanf("%d", &choice);


    if (choice == 1) {
        copy_char_by_char(source, destination);
    } else if (choice == 2) {
        copy_line_by_line(source, destination);
    } else {
        printf("Invalid choice.\n");
    }


    fclose(source);
    fclose(destination);

    return EXIT_SUCCESS;
}



//Write a program to read and copy the contents of file character by character, line by line.

#include <stdio.h>
#include <stdlib.h>

void copy_char_by_char(FILE *source) {
    char ch;
    while ((ch = fgetc(source)) != EOF) {
        putchar(ch);
    }
    printf("File copied character by character successfully.\n");
}

void copy_line_by_line(FILE *source) {
    char buffer[1024]; 
    while (fgets(buffer, sizeof(buffer), source) != NULL) {
        printf("%s", buffer);
    }
    printf("File copied line by line successfully.\n");
}

int main() {
    char source_file[100];
    int choice;

    printf("Enter the source file name: ");
    scanf("%s", source_file);

    FILE *source = fopen(source_file, "r");
    if (source == NULL) {
        perror("Error opening source file");
        return EXIT_FAILURE;
    }


    printf("Choose copy method:\n1. Copy character by character\n2. Copy line by line\n");
    scanf("%d", &choice);


    if (choice == 1) {
        copy_char_by_char(source);
    } else if (choice == 2) {
        copy_line_by_line(source);
    } else {
        printf("Invalid choice.\n");
    }


    fclose(source);

    return EXIT_SUCCESS;
}


/////////////////////////////

//25


//Write a program to load ALP program from input file to main memory.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MEMORY_SIZE 100  


void load_ALP_to_memory(const char *file_name) {
    FILE *file;
    char line[256]; 
    char *memory[MAX_MEMORY_SIZE]; 
    int memory_address = 0;  

  
    file = fopen(file_name, "r");
    if (file == NULL) {
        printf("Error: Could not open the file %s\n", file_name);
        return;
    }

    while (fgets(line, sizeof(line), file) != NULL) {
     
        line[strcspn(line, "\n")] = '\0';


        if (memory_address < MAX_MEMORY_SIZE) {
 
            memory[memory_address] = (char *)malloc(strlen(line) + 1);
            if (memory[memory_address] == NULL) {
                printf("Error: Memory allocation failed\n");
                fclose(file);
                return;
            }
            strcpy(memory[memory_address], line);
            printf("Loading Instruction: %s into memory at address %d\n", memory[memory_address], memory_address);
            memory_address++;
        } else {
            printf("Error: Memory overflow, too many instructions.\n");
            break;
        }
    }

    fclose(file);

    printf("\n--- Main Memory After Loading ALP ---\n");
    for (int i = 0; i < memory_address; i++) {
        printf("Memory[%d]: %s\n", i, memory[i]);
    }

    for (int i = 0; i < memory_address; i++) {
        free(memory[i]);
    }
}

int main() {
    char file_name[100];

    printf("Enter the ALP program file name: ");
    scanf("%s", file_name);

    load_ALP_to_memory(file_name);

    return 0;
}


MOV AX, 01
ADD AX, 05
MOV BX, AX
HLT


///////////////////////
//26

#include <stdio.h>
#include <string.h>

// Define the maximum number of instructions and the maximum length of an instruction
#define MAX_INSTRUCTIONS 100
#define MAX_OPCODE_LENGTH 10

// List of valid opcodes
const char *valid_opcodes[] = {"MOV", "ADD", "SUB", "MUL", "DIV", "HLT"};
#define NUM_VALID_OPCODES 6

// Function to check if an opcode is valid
int is_valid_opcode(const char *opcode) {
    for (int i = 0; i < NUM_VALID_OPCODES; i++) {
        if (strcmp(opcode, valid_opcodes[i]) == 0) {
            return 1;  // Valid opcode
        }
    }
    return 0;  // Invalid opcode
}

// Function to simulate loading and checking the job
void load_and_check_job(FILE *job_file) {
    char instruction[MAX_OPCODE_LENGTH + 50];  // to store each instruction
    char opcode[MAX_OPCODE_LENGTH];
    char operand[50];
    int line_num = 0;

    // Process each line in the job file
    while (fgets(instruction, sizeof(instruction), job_file) != NULL) {
        line_num++;
        
        // Parse the instruction (assuming format: OPCODE OPERAND)
        if (sscanf(instruction, "%s %s", opcode, operand) < 2) {
            printf("Error on line %d: Invalid instruction format!\n", line_num);
            continue;  // Skip invalid instructions
        }

        // Check if the opcode is valid
        if (!is_valid_opcode(opcode)) {
            printf("Interrupt: Invalid opcode '%s' found at line %d! Job halted.\n", opcode, line_num);
            return;  // Raise interrupt and stop further execution
        }

        // Print the valid instruction (simulating execution)
        printf("Executing instruction: %s %s\n", opcode, operand);
    }

    printf("Job completed without errors.\n");
}

int main() {
    char filename[50];

    // Ask for the input job file
    printf("Enter the job file name: ");
    scanf("%s", filename);

    // Open the file for reading
    FILE *job_file = fopen(filename, "r");
    if (job_file == NULL) {
        printf("Error opening file %s\n", filename);
        return 1;  // Exit if the file can't be opened
    }

    // Load and check the job file for opcode errors
    load_and_check_job(job_file);

    // Close the job file
    fclose(job_file);

    return 0;
}



MOV AX, 10
ADD BX, 5
MUL AX, 2
HLT
INVALID 100  // This will raise an interrupt


//////////////////////////////////

//27

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_LINE_LENGTH 100

const char *valid_registers[] = {"AX", "BX", "CX", "DX"};
int num_valid_registers = 4;

int is_valid_register(const char *operand) {
    for (int i = 0; i < num_valid_registers; i++) {
        if (strcmp(operand, valid_registers[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

int is_valid_immediate(const char *operand) {
    for (int i = 0; operand[i] != '\0'; i++) {
        if (!isdigit(operand[i])) {
            return 0;
        }
    }
    return 1;
}

void check_job_for_operand_errors(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("Error: Cannot open file %s\n", filename);
        return;
    }

    char line[MAX_LINE_LENGTH];
    int line_number = 0;

    while (fgets(line, sizeof(line), file)) {
        line_number++;
        char opcode[10], dest[10], src[10];

        int num_operands = sscanf(line, "%s %[^,], %s", opcode, dest, src);

        if (num_operands == 3) {
            if (!is_valid_register(dest)) {
                printf("Interrupt: Invalid destination operand '%s' on line %d. Job halted.\n", dest, line_number);
                fclose(file);
                return;
            }
            if (!is_valid_register(src) && !is_valid_immediate(src)) {
                printf("Interrupt: Invalid source operand '%s' on line %d. Job halted.\n", src, line_number);
                fclose(file);
                return;
            }
            printf("Executing instruction: %s %s, %s\n", opcode, dest, src);
        } else {
            printf("Error: Invalid instruction format on line %d.\n", line_number);
        }
    }

    printf("Job completed without errors.\n");
    fclose(file);
}

int main() {
    char filename[50];
    printf("Enter the job file name: ");
    scanf("%s", filename);
    check_job_for_operand_errors(filename);
    return 0;
}


MOV AX, 10
ADD BX, CX
SUB DX, 5
MOV AY, 20



